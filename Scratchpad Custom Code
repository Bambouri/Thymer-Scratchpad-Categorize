class Plugin extends CollectionPlugin {

    onLoad() {
        const config = this.getConfiguration();
        this.apiKey = config.custom?.anthropic_api_key || "";
        this.targetCollection = config.custom?.target_collection || "HQ";

        this.ui.addCommandPaletteCommand({
            id: "save-to-hq",
            label: "Save to HQ",
            icon: "ti-send",
            onSelected: () => this.saveToHQ()
        });

        console.log("Scratchpad plugin loaded!");
    }

    async saveToHQ() {
        const panel = this.ui.getActivePanel();
        if (!panel) {
            this.ui.addToaster({ title: "Error", message: "No active panel found", dismissible: true, autoDestroyTime: 3000 });
            return;
        }

        const record = panel.getActiveRecord();
        if (!record) {
            this.ui.addToaster({ title: "Error", message: "No active scratch found", dismissible: true, autoDestroyTime: 3000 });
            return;
        }

        const lineItems = await record.getLineItems();
        
        const originalLineData = [];
        let noteContent = "";
        
        for (const item of lineItems) {
            const lineData = {
                type: item.type || "text",
                segments: item.segments ? JSON.parse(JSON.stringify(item.segments)) : [{ type: "text", text: "" }],
                props: item.props ? JSON.parse(JSON.stringify(item.props)) : {}
            };
            originalLineData.push(lineData);
            
            if (item.segments) {
                for (const seg of item.segments) {
                    if (seg.text) noteContent += seg.text;
                }
            }
            noteContent += "\n";
        }
        
        noteContent = noteContent.trim();
        
        console.log("Lines:", originalLineData.length, "Content length:", noteContent.length);
        
        if (!noteContent) {
            this.ui.addToaster({ title: "Error", message: "Scratchpad is empty", dismissible: true, autoDestroyTime: 3000 });
            return;
        }

        this.ui.addToaster({ title: "Processing...", message: "Analyzing content", dismissible: true, autoDestroyTime: 2000 });

        await this.processAndSave(record, noteContent, originalLineData);
    }

    async clearScratchpad(record) {
        let attempts = 0;
        while (attempts < 20) {
            const items = await record.getLineItems();
            if (!items || items.length === 0) break;
            
            for (let i = items.length - 1; i >= 0; i--) {
                try { await items[i].delete(); } catch (e) { }
            }
            attempts++;
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    async processAndSave(record, noteContent, originalLineData) {
        if (!this.apiKey) {
            this.ui.addToaster({ title: "Error", message: "No API key configured", dismissible: true, autoDestroyTime: 3000 });
            return;
        }

        const collections = await this.data.getAllCollections();
        const targetColl = collections.find(c => c.getName() === this.targetCollection);
        
        if (!targetColl) {
            this.ui.addToaster({ title: "Error", message: "Collection not found", dismissible: true, autoDestroyTime: 3000 });
            return;
        }

        const targetConfig = targetColl.getConfiguration();
        const areaField = targetConfig.fields.find(f => f.label === "Area");
        const categoryField = targetConfig.fields.find(f => f.label === "Category");
        
        const areaOptions = areaField?.choices?.map(c => c.label) || ["Business", "Philosophy", "Life", "Other"];
        const categoryOptions = categoryField?.choices?.map(c => c.label) || ["Sales", "Marketing", "Product", "Operations", "Ideas", "Other"];

        try {
            const response = await fetch("https://api.anthropic.com/v1/messages", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "x-api-key": this.apiKey,
                    "anthropic-version": "2023-06-01",
                    "anthropic-dangerous-direct-browser-access": "true"
                },
                body: JSON.stringify({
                    model: "claude-sonnet-4-5-20250929",
                    max_tokens: 1000,
                    messages: [{
                        role: "user",
                        content: "Analyze this note and provide metadata only.\n\n1. AREA: Pick from: " + areaOptions.join(", ") + "\n2. CATEGORY: Pick from: " + categoryOptions.join(", ") + "\n3. TITLE: Max 7 words\n4. DESCRIPTION: 1-3 sentences\n\nNote:\n\"\"\"\n" + noteContent.substring(0, 8000) + "\n\"\"\"\n\nRespond with ONLY JSON:\n{\"area\": \"X\", \"category\": \"X\", \"title\": \"X\", \"description\": \"X\"}"
                    }]
                })
            });

            if (!response.ok) throw new Error("API error: " + response.status);

            const data = await response.json();
            let content = data.content[0].text.trim();
            
            if (content.startsWith("```json")) content = content.slice(7);
            if (content.startsWith("```")) content = content.slice(3);
            if (content.endsWith("```")) content = content.slice(0, -3);
            content = content.trim();
            
            let parsed;
            try {
                parsed = JSON.parse(content);
            } catch (e) {
                parsed = { area: "Other", category: "Other", title: "Untitled Note", description: "" };
            }

            console.log("Parsed:", parsed);

            const newGuid = targetColl.createRecord(parsed.title);
            if (!newGuid) throw new Error("Failed to create record");

            console.log("Created record GUID:", newGuid);

            await new Promise(resolve => setTimeout(resolve, 2000));

            const allRecords = await targetColl.getAllRecords();
            const newRecord = allRecords.find(r => r.guid === newGuid);
            
            if (!newRecord) throw new Error("Could not find new record");

            console.log("Found new record, setting properties...");

            // Set properties
            const descProp = newRecord.prop("Description");
            if (descProp) descProp.set(parsed.description);

            const areaProp = newRecord.prop("Area");
            if (areaProp && parsed.area) {
                const areaChoice = areaField?.choices?.find(c => c.label === parsed.area);
                if (areaChoice) areaProp.set(areaChoice.id);
            }

            const categoryProp = newRecord.prop("Category");
            if (categoryProp && parsed.category) {
                const categoryChoice = categoryField?.choices?.find(c => c.label === parsed.category);
                if (categoryChoice) categoryProp.set(categoryChoice.id);
            }

            // Add line items in REVERSE order (since createLineItem inserts at top)
            console.log("Adding", originalLineData.length, "line items...");
            
            for (let i = originalLineData.length - 1; i >= 0; i--) {
                const lineData = originalLineData[i];
                
                try {
                    const lineItem = await newRecord.createLineItem(null, null, lineData.type);
                    if (lineItem) {
                        await lineItem.setSegments(lineData.segments);
                        
                        if ((originalLineData.length - i) % 10 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                        if ((originalLineData.length - i) % 50 === 0) {
                            console.log("Added", originalLineData.length - i, "lines...");
                        }
                    }
                } catch (lineError) {
                    console.error("Error on line", i, ":", lineError);
                }
            }

            await new Promise(resolve => setTimeout(resolve, 1000));
            
            const finalItems = await newRecord.getLineItems();
            console.log("Final line count:", finalItems.length);

            this.ui.addToaster({ title: "Saved!", message: "Clearing scratchpad...", dismissible: true, autoDestroyTime: 2000 });

            await this.clearScratchpad(record);

            this.ui.addToaster({ title: "Done!", message: parsed.title, dismissible: true, autoDestroyTime: 3000 });

        } catch (e) {
            console.error("Error:", e);
            this.ui.addToaster({ title: "Error", message: e.message, dismissible: true, autoDestroyTime: 3000 });
        }
    }
}
